grammar com.yakindu.solidity.Solidity with org.yakindu.base.expressions.Expressions

generate solidity "http://www.yakindu.com/solidity/Solidity"
import "http://www.yakindu.org/base/expressions/Expressions" as expressions
import "http://www.eclipse.org/emf/2002/Ecore"
import "http://www.yakindu.org/base/types/2.0.0" as types

SolidityModel:
	(sourceunit+=SourceUnit)*;

terminal VERSION:
	'^' INT . INT . INT;

SourceUnit returns types::Package:
	{SourceUnit}
	(pragma=PragmaDirective)?
	(imports+=ImportDirective)*
	member+=ContractDefinition;

PragmaDirective returns types::PackageMember:
	{PragmaDirective} 'pragma' 'solidity' version=VERSION ';';

ImportDirective returns types::PackageMember:
	{ImportDirective} 'import' importedNamespace=STRING ('as' alias=STRING)? ';';

ContractDefinition returns types::ComplexType:
	{ContractDefinition} type=ContractType name=ID
	('is' superTypes+=[types::ComplexType|QID] (',' superTypes+=[types::ComplexType|QID])*)?
	'{' (features+=ContractPart)* '}';

enum ContractType:
	CONTRACT='contract' | LIBRARY='library' | INTERFACE='interface';

ContractPart returns types::Declaration:
	StateVariableDefinition | ModifierDefinition | FunctionDefinition | EventDefinition |
	TypeDefinition;

StateVariableDefinition returns types::Property:
	{VariableDefinition} typeSpecifier=TypeSpecifier (visibility=Visibility)? name=ID ('=' initialValue=Expression)? ';';

@ Override TypeSpecifier returns types::TypeSpecifier:
	{TypeSpecifier} type=[types::Type|QID] ('[' index+=Expression ']')*;

VariableDeclaration returns types::Property:
	{VariableDefinition} typeSpecifier=TypeSpecifier name=ID;

enum Visibility:
	PUBLIC='public' | INTERNAL='internal' | PRIVATE='private' | CONSTANT='constant';

	//TODO This is a hack.
TypeDefinition returns types::Declaration:
	{TypeDefinition} definition=(StructDefinition | EnumDefinition);

StructDefinition returns types::ComplexType:
	{StructDefinition} 'struct' name=ID '{'
	(features+=VariableDeclaration ';')* '}';

EnumDefinition returns types::EnumerationType:
	'enum' name=ID '{' (enumerator+=Enumerator (',' enumerator+=Enumerator)*)? '}';

Enumerator returns types::Enumerator:
	name=ID;

ModifierDefinition returns types::Operation:
	{ModifierDefinition} 'modifier' name=ID list=ParameterList
	block+=Block;

ParameterList:
	{ParameterList} '(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')';

Block:
	'{' {Block} (statements+=Statement)* '}';

@ Override Literal returns expressions::Literal:
	super | ModifierInvocationLiteral;

ModifierInvocationLiteral:
	{ModifierInvocationLiteral} '_;';

FunctionDefinition returns types::Operation:
	{FunctionDefinition} 'function' name=ID? list=ParameterList
	('external' | 'public' | 'internal' | 'private' | 'constant')*
	('returns' ('(' returnTypes+=TypeSpecifier (',' retunTypes+=TypeSpecifier)? ')')?)? (';' | (block=Block));

Parameter returns types::Parameter:
	typeSpecifier=TypeSpecifier name=ID;

EventDefinition returns types::Event:
	'event' name=ID;

Statement:
	IfStatement | WhileStatement | Block | (ReturnStatement | ExpressionStatement | VariableDefinition) ';';

ReturnStatement:
	{ReturnStatement} 'return' (expression=Expression)?;

ExpressionStatement:
	expression=Expression;

VariableDefinitionProperty returns types::Property:
	VariableDefinition
;

VariableDefinition:
	=>('var' | typeSpecifier=TypeSpecifier) name=ID ('=' initialValue=Expression)?;

IfStatement:
	'if' '(' condition=Expression ')'
	then=Statement
	(=> 'else' else=Statement)?;

WhileStatement:
	'while' '(' condition=Expression ')' body=Statement;
