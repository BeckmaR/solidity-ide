grammar com.yakindu.solidity.Solidity with org.yakindu.base.expressions.Expressions

generate solidity "http://www.yakindu.com/solidity/Solidity"
import "http://www.yakindu.org/base/expressions/Expressions" as expressions
import "http://www.eclipse.org/emf/2002/Ecore"
import "http://www.yakindu.org/base/types/2.0.0" as types

SolidityModel:
	(sourceunit+=SourceUnit)*;

terminal VERSION:
	'^' INT . INT . INT;

SourceUnit returns types::Package:
	{SourceUnit}
	(pragma=PragmaDirective)?
	(imports+=ImportDirective)*
	member+=ContractDefinition;

PragmaDirective returns types::PackageMember:
	{PragmaDirective} 'pragma' 'solidity' version=VERSION ';';

ImportDirective returns types::PackageMember:
	{ImportDirective} 'import' importedNamespace=STRING ('as' alias=STRING)? ';';

ContractDefinition returns types::ComplexType:
	{ContractDefinition} type=ContractType name=ID
	('is' superTypes+=[types::ComplexType|QID] (',' superTypes+=[types::ComplexType|QID])*)?
	'{' (features+=ContractPart)* '}';

enum ContractType:
	CONTRACT='contract' | LIBRARY='library' | INTERFACE='interface';

ContractPart returns types::Declaration:
	VariableDefinition | ModifierDefinition | FunctionDefinition | EventDefinition;
	//StructDefinition | | EnumDefinition;
VariableDefinition returns types::Property:
	{VariableDefinition} typeSpecifier=TypeSpecifier (visibility=Visibility)? name=ID ('=' initialValue=Expression)? ';';

enum Visibility:
	PUBLIC='public' | INTERNAL='internal' | PRIVATE='private' | CONSTANT='constant';

StructDefinition returns types::ComplexType:
	'struct' name=ID '{'
	(features+=VariableDefinition ';')* '}';

ModifierDefinition returns types::Operation:
	{ModifierDefinition} 'modifier' name=ID list=ParameterList
	block+=Block;

ParameterList:
	{ParameterList} '(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')';

Block:
	'{' {Block} (statements+=Statement)* '}';

@ Override Literal returns expressions::Literal:
	super | ModifierInvocationLiteral;

ModifierInvocationLiteral:
	{ModifierInvocationLiteral} '_;';

FunctionDefinition returns types::Operation:
	{FunctionDefinition} 'function' name=ID? list=ParameterList
	('external' | 'public' | 'internal' | 'private' | 'constant')*
	('returns' ('(' returnTypes+=TypeSpecifier (',' retunTypes+=TypeSpecifier)? ')')?)? (';' | (block=Block));

Parameter returns types::Parameter:
	typeSpecifier=TypeSpecifier name=ID;

EventDefinition returns types::Event:
	'event' name=ID;

Statement:
	IfStatement | WhileStatement | ReturnStatement | Block | ExpressionStatement ';';

ReturnStatement:
	{ReturnStatement} 'return';

ExpressionStatement:
	expression=Expression;

IfStatement:
	'if' '(' condition=Expression ')'
	then=Statement
	(=>'else' else=Statement)?;

WhileStatement:
	'while' '(' condition=Expression ')' body=Statement;
