/**
 * 
 * @author andreas muelder
 * @author florian antony
 * 
 */
grammar com.yakindu.solidity.Solidity with org.yakindu.base.expressions.Expressions

generate solidity "http://www.yakindu.com/solidity/Solidity"
import "http://www.yakindu.org/base/expressions/Expressions" as expressions
import "http://www.eclipse.org/emf/2002/Ecore"
import "http://www.yakindu.org/base/types/2.0.0" as types

SolidityModel:
	(sourceunit+=SourceUnit)*;

terminal VERSION:
	'^' INT . INT . INT;

SourceUnit returns types::Package:
	{SourceUnit}
	((pragma=PragmaDirective)? &
	(imports+=ImportDirective)* &
	member+=ContractDefinition);

PragmaDirective returns types::PackageMember:
	{PragmaDirective} 'pragma' 'solidity' version=VERSION ';';

ImportDirective returns types::PackageMember:
	{ImportDirective} 'import' importedNamespace=STRING ('as' alias=STRING)? ';';

ContractDefinition returns types::ComplexType:
	{ContractDefinition} type=ContractType name=ID
	('is' superTypes+=[types::ComplexType|QID] (',' superTypes+=[types::ComplexType|QID])*)?
	'{' (features+=ContractPart)* '}';

enum ContractType:
	CONTRACT='contract' | LIBRARY='library' | INTERFACE='interface';

ContractPart returns types::Declaration:
	StateVariableDefinition | ModifierDefinition | FunctionDefinition | EventDefinition |
	TypeDefinition;

StateVariableDefinition returns types::Property:
	{VariableDefinition} typeSpecifier=TypeSpecifier (visibility=Visibility)? name=ID ('=' initialValue=Expression)? ';';

@ Override TypeSpecifier:
	SimpleTypeSpecifier | MappingTypeSpecifier | ArrayTypeSpecifier;

MappingTypeSpecifier:
	{MappingTypeSpecifier} 'mapping' '(' from=TypeSpecifier '=>' to=TypeSpecifier ')';

ArrayTypeSpecifier:
	{SimpleTypeSpecifier} type=[types::Type|QID] ('[' (index+=Expression)? ']')+;

SimpleTypeSpecifier returns TypeSpecifier:
	type=[types::Type|QID];

VariableDeclaration returns types::Property:
	{VariableDefinition} typeSpecifier=TypeSpecifier name=ID;

enum Visibility:
	PUBLIC='public' | INTERNAL='internal' | PRIVATE='private' | CONSTANT='constant';

enum Unit:
	SECONDS='seconds' | MINUTES='minutes' | HOURS='hours' | DAYS='days' | WEEKS='weeks' | YEARS='years' | WEI='wei' |
	FINNEY='finney' | SZABO='szabo' | ETHER='ether';

	//TODO This is a hack.
TypeDefinition returns types::Declaration:
	{TypeDefinition} definition=(StructDefinition | EnumDefinition);

StructDefinition returns types::ComplexType:
	{StructDefinition} 'struct' name=ID '{'
	(features+=VariableDeclaration ';')* '}';

EnumDefinition returns types::EnumerationType:
	'enum' name=ID '{' (enumerator+=Enumerator (',' enumerator+=Enumerator)*)? '}';

Enumerator returns types::Enumerator:
	name=ID;

ModifierDefinition returns types::Operation:
	{ModifierDefinition} 'modifier' name=ID ('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')')?
	block+=Block;

Block:
	'{' {Block} (statements+=Statement)* '}';

@ Override Literal returns expressions::Literal:
	BoolLiteral | BigIntLiteral | AddressLiteral | BinaryLiteral | DoubleLiteral | FloatLiteral | StringLiteral |
	NullLiteral | ModifierInvocationLiteral;

BigIntLiteral:
	value=BIGINT (unit=Unit)?;

AddressLiteral:
	value=ADDRESS;

ModifierInvocationLiteral:
	{ModifierInvocationLiteral} '_;';

FunctionDefinition returns types::Operation:
	{FunctionDefinition} 'function' name=ID? '(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')'
	('external' | 'public' | 'internal' | 'private' | 'pure' | 'constant' | 'view' | 'payable')*
	('returns' '(' (returnParameters+=Parameter (',' returnParameters+=Parameter)*)? ')')? (';' | (block=Block));

Parameter returns types::Parameter:
	typeSpecifier=TypeSpecifier (name=ID)?;

IndexParameter returns types::Parameter:
	{IndexParameter} typeSpecifier=TypeSpecifier (indexed?="indexed")? (name=ID)?;

EventDefinition returns types::Operation:
	{EventDefinition} 'event' name=ID '(' (parameters+=IndexParameter (',' parameters+=IndexParameter)*)? ')' ';';

Statement:
	IfStatement | WhileStatement | ForStatement | Block | PlaceholderStatement | (ThrowStatement | ReturnStatement | SimpleStatement) ';';

ThrowStatement:
	{ThrowStatement} 'throw';

SimpleStatement:
	VariableDefinition | ExpressionStatement;

PlaceholderStatement:
	{PlaceholderStatement} '_'
;

ReturnStatement:
	{ReturnStatement} 'return' (expression=Expression)?;

ExpressionStatement:
	expression=Expression;

@ Override NumericalMultiplyDivideExpression returns expressions::Expression:
	NumericalUnaryExpression
	=> ({NumericalMultiplyDivideExpression.leftOperand=current}
	operator=MultiOperator
	rightOperand=NumericalUnaryExpression)*;

enum MultiOperator:
	mul='*' | div='/' | mod='%' | exp="**";

	// Remove TypeCast Expression
@ Override NumericalUnaryExpression returns expressions::Expression:
	PostFixUnaryExpression | {expressions::NumericalUnaryExpression}
	operator=UnaryOperator operand=PostFixUnaryExpression;

PostFixUnaryExpression returns expressions::Expression:
	PrimaryExpression ({PostFixUnaryExpression.operand=current} operator=PostFixOperator)*;

enum PostFixOperator:
	increment="++" | decrement="--";

@ Override PrimaryExpression returns expressions::Expression:
	super | NewInstanceExpression;

NewInstanceExpression returns expressions::FeatureCall:
	{NewInstanceExpression} 'new' type=TypeSpecifier operationCall?='(' (arguments+=Argument (',' arguments+=Argument)*)?
	')';

VariableDefinitionProperty returns types::Property:
	VariableDefinition;

VariableDefinition:
	('var' | typeSpecifier=SimpleTypeSpecifier) name=ID ('=' initialValue=Expression)?;

IfStatement:
	'if' '(' condition=Expression ')'
	then=Statement
	(=> 'else' else=Statement)?;

WhileStatement:
	'while' '(' condition=Expression ')' body=Statement;

ForStatement:
	'for' '(' (initialization=SimpleStatement)? ';' (condition=Expression)? ';' (afterthought=Expression)? ')'
	statement=Statement;

terminal ADDRESS returns EBigInteger:
	('0') ('x' | 'X') ('0'..'9' | 'a'..'f' | 'A'..'F')+;

terminal BIGINT returns EBigInteger:
	('0'..'9')+;

