/*
 * generated by Xtext 2.12.0
 */
package com.yakindu.solidity.serializer;

import com.google.inject.Inject;
import com.yakindu.solidity.services.SolidityGrammarAccess;
import com.yakindu.solidity.solidity.Block;
import com.yakindu.solidity.solidity.ContractDefinition;
import com.yakindu.solidity.solidity.FunctionDefinition;
import com.yakindu.solidity.solidity.ImportDirective;
import com.yakindu.solidity.solidity.ModifierDefinition;
import com.yakindu.solidity.solidity.ModifierInvocationLiteral;
import com.yakindu.solidity.solidity.ParameterList;
import com.yakindu.solidity.solidity.PragmaDirective;
import com.yakindu.solidity.solidity.SolidityModel;
import com.yakindu.solidity.solidity.SolidityPackage;
import com.yakindu.solidity.solidity.SourceUnit;
import com.yakindu.solidity.solidity.VariableDefinition;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.yakindu.base.base.BasePackage;
import org.yakindu.base.expressions.expressions.Argument;
import org.yakindu.base.expressions.expressions.AssignmentExpression;
import org.yakindu.base.expressions.expressions.BinaryLiteral;
import org.yakindu.base.expressions.expressions.BitwiseAndExpression;
import org.yakindu.base.expressions.expressions.BitwiseOrExpression;
import org.yakindu.base.expressions.expressions.BitwiseXorExpression;
import org.yakindu.base.expressions.expressions.BoolLiteral;
import org.yakindu.base.expressions.expressions.ConditionalExpression;
import org.yakindu.base.expressions.expressions.DoubleLiteral;
import org.yakindu.base.expressions.expressions.ElementReferenceExpression;
import org.yakindu.base.expressions.expressions.ExpressionsPackage;
import org.yakindu.base.expressions.expressions.FeatureCall;
import org.yakindu.base.expressions.expressions.FloatLiteral;
import org.yakindu.base.expressions.expressions.HexLiteral;
import org.yakindu.base.expressions.expressions.IntLiteral;
import org.yakindu.base.expressions.expressions.LogicalAndExpression;
import org.yakindu.base.expressions.expressions.LogicalNotExpression;
import org.yakindu.base.expressions.expressions.LogicalOrExpression;
import org.yakindu.base.expressions.expressions.LogicalRelationExpression;
import org.yakindu.base.expressions.expressions.NullLiteral;
import org.yakindu.base.expressions.expressions.NumericalAddSubtractExpression;
import org.yakindu.base.expressions.expressions.NumericalMultiplyDivideExpression;
import org.yakindu.base.expressions.expressions.NumericalUnaryExpression;
import org.yakindu.base.expressions.expressions.ParenthesizedExpression;
import org.yakindu.base.expressions.expressions.PrimitiveValueExpression;
import org.yakindu.base.expressions.expressions.ShiftExpression;
import org.yakindu.base.expressions.expressions.StringLiteral;
import org.yakindu.base.expressions.expressions.TypeCastExpression;
import org.yakindu.base.expressions.serializer.ExpressionsSemanticSequencer;
import org.yakindu.base.types.ComplexType;
import org.yakindu.base.types.Event;
import org.yakindu.base.types.TypeSpecifier;
import org.yakindu.base.types.TypesPackage;

@SuppressWarnings("all")
public class SoliditySemanticSequencer extends ExpressionsSemanticSequencer {

	@Inject
	private SolidityGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ExpressionsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ExpressionsPackage.ARGUMENT:
				sequence_Argument(context, (Argument) semanticObject); 
				return; 
			case ExpressionsPackage.ASSIGNMENT_EXPRESSION:
				sequence_AssignmentExpression(context, (AssignmentExpression) semanticObject); 
				return; 
			case ExpressionsPackage.BINARY_LITERAL:
				sequence_BinaryLiteral(context, (BinaryLiteral) semanticObject); 
				return; 
			case ExpressionsPackage.BITWISE_AND_EXPRESSION:
				sequence_BitwiseAndExpression(context, (BitwiseAndExpression) semanticObject); 
				return; 
			case ExpressionsPackage.BITWISE_OR_EXPRESSION:
				sequence_BitwiseOrExpression(context, (BitwiseOrExpression) semanticObject); 
				return; 
			case ExpressionsPackage.BITWISE_XOR_EXPRESSION:
				sequence_BitwiseXorExpression(context, (BitwiseXorExpression) semanticObject); 
				return; 
			case ExpressionsPackage.BOOL_LITERAL:
				sequence_BoolLiteral(context, (BoolLiteral) semanticObject); 
				return; 
			case ExpressionsPackage.CONDITIONAL_EXPRESSION:
				sequence_ConditionalExpression(context, (ConditionalExpression) semanticObject); 
				return; 
			case ExpressionsPackage.DOUBLE_LITERAL:
				sequence_DoubleLiteral(context, (DoubleLiteral) semanticObject); 
				return; 
			case ExpressionsPackage.ELEMENT_REFERENCE_EXPRESSION:
				sequence_ElementReferenceExpression(context, (ElementReferenceExpression) semanticObject); 
				return; 
			case ExpressionsPackage.FEATURE_CALL:
				sequence_FeatureCall(context, (FeatureCall) semanticObject); 
				return; 
			case ExpressionsPackage.FLOAT_LITERAL:
				sequence_FloatLiteral(context, (FloatLiteral) semanticObject); 
				return; 
			case ExpressionsPackage.HEX_LITERAL:
				sequence_HexLiteral(context, (HexLiteral) semanticObject); 
				return; 
			case ExpressionsPackage.INT_LITERAL:
				sequence_IntLiteral(context, (IntLiteral) semanticObject); 
				return; 
			case ExpressionsPackage.LOGICAL_AND_EXPRESSION:
				sequence_LogicalAndExpression(context, (LogicalAndExpression) semanticObject); 
				return; 
			case ExpressionsPackage.LOGICAL_NOT_EXPRESSION:
				sequence_LogicalNotExpression(context, (LogicalNotExpression) semanticObject); 
				return; 
			case ExpressionsPackage.LOGICAL_OR_EXPRESSION:
				sequence_LogicalOrExpression(context, (LogicalOrExpression) semanticObject); 
				return; 
			case ExpressionsPackage.LOGICAL_RELATION_EXPRESSION:
				sequence_LogicalRelationExpression(context, (LogicalRelationExpression) semanticObject); 
				return; 
			case ExpressionsPackage.NULL_LITERAL:
				sequence_NullLiteral(context, (NullLiteral) semanticObject); 
				return; 
			case ExpressionsPackage.NUMERICAL_ADD_SUBTRACT_EXPRESSION:
				sequence_NumericalAddSubtractExpression(context, (NumericalAddSubtractExpression) semanticObject); 
				return; 
			case ExpressionsPackage.NUMERICAL_MULTIPLY_DIVIDE_EXPRESSION:
				sequence_NumericalMultiplyDivideExpression(context, (NumericalMultiplyDivideExpression) semanticObject); 
				return; 
			case ExpressionsPackage.NUMERICAL_UNARY_EXPRESSION:
				sequence_NumericalUnaryExpression(context, (NumericalUnaryExpression) semanticObject); 
				return; 
			case ExpressionsPackage.PARENTHESIZED_EXPRESSION:
				sequence_ParenthesizedExpression(context, (ParenthesizedExpression) semanticObject); 
				return; 
			case ExpressionsPackage.PRIMITIVE_VALUE_EXPRESSION:
				sequence_PrimitiveValueExpression(context, (PrimitiveValueExpression) semanticObject); 
				return; 
			case ExpressionsPackage.SHIFT_EXPRESSION:
				sequence_ShiftExpression(context, (ShiftExpression) semanticObject); 
				return; 
			case ExpressionsPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case ExpressionsPackage.TYPE_CAST_EXPRESSION:
				sequence_TypeCastExpression(context, (TypeCastExpression) semanticObject); 
				return; 
			}
		else if (epackage == SolidityPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SolidityPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case SolidityPackage.CONTRACT_DEFINITION:
				sequence_ContractDefinition(context, (ContractDefinition) semanticObject); 
				return; 
			case SolidityPackage.FUNCTION_DEFINITION:
				sequence_FunctionDefinition(context, (FunctionDefinition) semanticObject); 
				return; 
			case SolidityPackage.IMPORT_DIRECTIVE:
				sequence_ImportDirective(context, (ImportDirective) semanticObject); 
				return; 
			case SolidityPackage.MODIFIER_DEFINITION:
				sequence_ModifierDefinition(context, (ModifierDefinition) semanticObject); 
				return; 
			case SolidityPackage.MODIFIER_INVOCATION_LITERAL:
				sequence_ModifierInvocationLiteral(context, (ModifierInvocationLiteral) semanticObject); 
				return; 
			case SolidityPackage.PARAMETER_LIST:
				sequence_ParameterList(context, (ParameterList) semanticObject); 
				return; 
			case SolidityPackage.PRAGMA_DIRECTIVE:
				sequence_PragmaDirective(context, (PragmaDirective) semanticObject); 
				return; 
			case SolidityPackage.SOLIDITY_MODEL:
				sequence_SolidityModel(context, (SolidityModel) semanticObject); 
				return; 
			case SolidityPackage.SOURCE_UNIT:
				sequence_SourceUnit(context, (SourceUnit) semanticObject); 
				return; 
			case SolidityPackage.VARIABLE_DEFINITION:
				sequence_VariableDefinition(context, (VariableDefinition) semanticObject); 
				return; 
			}
		else if (epackage == TypesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TypesPackage.COMPLEX_TYPE:
				sequence_StructDefinition(context, (ComplexType) semanticObject); 
				return; 
			case TypesPackage.EVENT:
				sequence_EventDefinition(context, (Event) semanticObject); 
				return; 
			case TypesPackage.PARAMETER:
				sequence_Parameter(context, (org.yakindu.base.types.Parameter) semanticObject); 
				return; 
			case TypesPackage.TYPE_SPECIFIER:
				sequence_TypeSpecifier(context, (TypeSpecifier) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Block returns Block
	 *
	 * Constraint:
	 *     expression+=Expression*
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContractDefinition returns ContractDefinition
	 *
	 * Constraint:
	 *     (type=ContractType name=ID (superTypes+=[ComplexType|QID] superTypes+=[ComplexType|QID]*)? features+=ContractPart*)
	 */
	protected void sequence_ContractDefinition(ISerializationContext context, ContractDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContractPart returns Event
	 *     EventDefinition returns Event
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_EventDefinition(ISerializationContext context, Event semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BasePackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BasePackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEventDefinitionAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ContractPart returns FunctionDefinition
	 *     FunctionDefinition returns FunctionDefinition
	 *
	 * Constraint:
	 *     (name=ID? (parameters+=Parameter parameters+=Parameter*)? returnTypes+=TypeSpecifier* block=Block?)
	 */
	protected void sequence_FunctionDefinition(ISerializationContext context, FunctionDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImportDirective returns ImportDirective
	 *
	 * Constraint:
	 *     (importedNamespace=STRING alias=STRING?)
	 */
	protected void sequence_ImportDirective(ISerializationContext context, ImportDirective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContractPart returns ModifierDefinition
	 *     ModifierDefinition returns ModifierDefinition
	 *
	 * Constraint:
	 *     (name=ID list=ParameterList block+=Block)
	 */
	protected void sequence_ModifierDefinition(ISerializationContext context, ModifierDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns ModifierInvocationLiteral
	 *     ModifierInvocationLiteral returns ModifierInvocationLiteral
	 *
	 * Constraint:
	 *     {ModifierInvocationLiteral}
	 */
	protected void sequence_ModifierInvocationLiteral(ISerializationContext context, ModifierInvocationLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterList returns ParameterList
	 *
	 * Constraint:
	 *     (parameter+=Parameter? parameter+=Parameter*)
	 */
	protected void sequence_ParameterList(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (typeSpecifier=TypeSpecifier name=ID)
	 */
	protected void sequence_Parameter(ISerializationContext context, org.yakindu.base.types.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.TYPED_ELEMENT__TYPE_SPECIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.TYPED_ELEMENT__TYPE_SPECIFIER));
			if (transientValues.isValueTransient(semanticObject, BasePackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BasePackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getTypeSpecifierTypeSpecifierParserRuleCall_0_0(), semanticObject.getTypeSpecifier());
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PragmaDirective returns PragmaDirective
	 *
	 * Constraint:
	 *     version=VERSION
	 */
	protected void sequence_PragmaDirective(ISerializationContext context, PragmaDirective semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.Literals.PRAGMA_DIRECTIVE__VERSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.Literals.PRAGMA_DIRECTIVE__VERSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPragmaDirectiveAccess().getVersionVERSIONTerminalRuleCall_3_0(), semanticObject.getVersion());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SolidityModel returns SolidityModel
	 *
	 * Constraint:
	 *     sourceunit+=SourceUnit+
	 */
	protected void sequence_SolidityModel(ISerializationContext context, SolidityModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SourceUnit returns SourceUnit
	 *
	 * Constraint:
	 *     (pragma=PragmaDirective imports+=ImportDirective* member+=ContractDefinition*)
	 */
	protected void sequence_SourceUnit(ISerializationContext context, SourceUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StructDefinition returns ComplexType
	 *
	 * Constraint:
	 *     (name=ID features+=VariableDefinition*)
	 */
	protected void sequence_StructDefinition(ISerializationContext context, ComplexType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContractPart returns VariableDefinition
	 *     VariableDefinition returns VariableDefinition
	 *
	 * Constraint:
	 *     (typeSpecifier=TypeSpecifier visibility=Visibility? name=ID initialValue=Expression?)
	 */
	protected void sequence_VariableDefinition(ISerializationContext context, VariableDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
